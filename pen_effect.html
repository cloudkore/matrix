<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  canvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: pointer;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
  }

  .ui-panel {
    position: absolute;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    background: rgba(0, 0, 0, .7);
    border-radius: 12px;
    border: 1px solid rgba(255, 120, 50, .3);
    box-shadow: 0 4px 20px rgba(0, 0, 0, .5);
    z-index: 10;
    padding: 15px;
    color: #eee;
    font-family: 'Inter', sans-serif;
  }

  #instructions-container {
    top: 20px;
    left: 20px;
    font-size: 14px;
    line-height: 1.5;
    max-width: 280px;
  }

  #instruction-title {
    font-weight: 600;
    margin-bottom: 6px;
    font-size: 15px;
  }

  #theme-selector {
    top: 20px;
    right: 20px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    max-width: 150px;
  }

  #theme-selector-title {
    font-weight: 600;
    font-size: 15px;
    margin-bottom: 2px;
  }

  .theme-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
  }

  .theme-button {
    width: 36px;
    height: 36px;
    border-radius: 8px;
    border: 2px solid rgba(255, 255, 255, .3);
    cursor: pointer;
    transition: transform .2s, border-color .2s;
    outline: none;
    overflow: hidden;
  }

  .theme-button:hover,
  .theme-button:focus {
    transform: scale(1.05);
    border-color: rgba(255, 255, 255, .7);
  }

  .theme-button.active {
    transform: scale(1.05);
    border-color: rgba(255, 255, 255, .9);
    box-shadow: 0 0 10px rgba(255, 200, 150, .6);
  }

  #theme-1 {
    background: linear-gradient(45deg, #4F46E5, #7C3AED, #C026D3, #DB2777);
  }

  #theme-2 {
    background: linear-gradient(45deg, #F59E0B, #F97316, #DC2626, #7F1D1D);
  }

  #theme-3 {
    background: linear-gradient(45deg, #EC4899, #8B5CF6, #6366F1, #3B82F6);
  }

  #theme-4 {
    background: linear-gradient(45deg, #10B981, #A3E635, #FACC15, #FB923C);
  }

  #density-controls {
    margin-top: 8px;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .density-label {
    font-size: 13px;
    display: flex;
    justify-content: space-between;
  }

  .density-slider {
    width: 100%;
    appearance: none;
    height: 4px;
    border-radius: 2px;
    background: rgba(255, 120, 50, .3);
    outline: none;
    cursor: pointer;
  }

  .density-slider::-webkit-slider-thumb {
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: rgba(255, 120, 50, .8);
    cursor: pointer;
    transition: transform .1s, background .1s;
  }

  .density-slider::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: rgba(255, 120, 50, .8);
    cursor: pointer;
    border: none;
    transition: transform .1s, background .1s;
  }

  .density-slider::-webkit-slider-thumb:hover {
    transform: scale(1.1);
    background: rgba(255, 140, 50, 1);
  }

  .density-slider::-moz-range-thumb:hover {
    transform: scale(1.1);
    background: rgba(255, 140, 50, 1);
  }

  #control-buttons {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 15px;
    z-index: 10;
    background: rgba(0, 0, 0, .6);
    padding: 10px 15px;
    border-radius: 10px;
    border: 1px solid rgba(255, 120, 50, .2);
  }

  .control-button {
    background: rgba(255, 120, 50, .2);
    color: #eee;
    border: 1px solid rgba(255, 150, 50, .3);
    padding: 8px 15px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: background-color 0.2s, transform 0.1s;
    white-space: nowrap;
    min-width: 80px;
    text-align: center;
    font-family: 'Inter', sans-serif;
  }

  .control-button:hover,
  .control-button:focus {
    background: rgba(255, 120, 50, .4);
    outline: none;
  }

  .control-button:active {
    background: rgba(255, 120, 50, .6);
    transform: scale(0.95);
  }

  @media (max-width: 640px) {
    #instructions-container {
      max-width: calc(100% - 40px);
      font-size: 13px;
      padding: 10px 15px;
      top: 10px;
      left: 10px;
    }

    #instruction-title {
      font-size: 14px;
    }

    #theme-selector {
      top: auto;
      bottom: 20px;
      right: 10px;
      left: auto;
      transform: none;
      max-width: 120px;
      padding: 10px;
    }

    #theme-selector-title {
      font-size: 14px;
    }

    .theme-button {
      width: 30px;
      height: 30px;
    }

    .density-label {
      font-size: 12px;
    }

    #control-buttons {
      bottom: 10px;
      gap: 10px;
      padding: 8px 10px;
    }

    .control-button {
      padding: 6px 10px;
      font-size: 12px;
      min-width: 65px;
    }
  }

  @media (max-width: 400px) {
    #theme-selector {
      flex-direction: column;
      align-items: center;
      max-width: none;
      width: calc(100% - 20px);
      left: 10px;
      right: 10px;
      bottom: 75px;
    }

    .theme-grid {
      grid-template-columns: repeat(4, 1fr);
      width: 100%;
      justify-items: center;
    }

    #density-controls {
      width: 80%;
      margin-top: 15px;
    }

    #control-buttons {
      width: calc(100% - 20px);
      justify-content: space-around;
    }
  }
</style>

<div id="instructions-container" class="ui-panel">
  <div id="instruction-title">Interactive Neural Network</div>
  <div>Click or tap to create energy pulses through the network. Drag to rotate.</div>
</div>

<div id="theme-selector" class="ui-panel">
  <div id="theme-selector-title">Visual Theme</div>
  <div class="theme-grid">
    <button class="theme-button" id="theme-1" data-theme="0" aria-label="Theme 1"></button>
    <button class="theme-button" id="theme-2" data-theme="1" aria-label="Theme 2"></button>
    <button class="theme-button" id="theme-3" data-theme="2" aria-label="Theme 3"></button>
    <button class="theme-button" id="theme-4" data-theme="3" aria-label="Theme 4"></button>
  </div>
  <div id="density-controls">
    <div class="density-label"><span>Density</span><span id="density-value">100%</span></div>
    <input type="range" min="20" max="100" value="100" class="density-slider" id="density-slider" aria-label="Network Density">
  </div>
</div>

<div id="control-buttons">
  <button id="change-formation-btn" class="control-button">Formation</button>
  <button id="pause-play-btn" class="control-button">Pause</button>
  <button id="reset-camera-btn" class="control-button">Reset Cam</button>
</div>

<canvas id="neural-network-canvas"></canvas>

<script type="importmap">
  {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
      }
    }
    </script>

<script type="module">
  import * as THREE from 'three';
  import {
    OrbitControls
  } from 'three/addons/controls/OrbitControls.js';
  import {
    EffectComposer
  } from 'three/addons/postprocessing/EffectComposer.js';
  import {
    RenderPass
  } from 'three/addons/postprocessing/RenderPass.js';
  import {
    UnrealBloomPass
  } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import {
    FilmPass
  } from 'three/addons/postprocessing/FilmPass.js';
  import {
    OutputPass
  } from 'three/addons/postprocessing/OutputPass.js';
  const config = {
    paused: false,
    activePaletteIndex: 1,
    currentFormation: 0,
    numFormations: 4,
    densityFactor: 1
  };
  const colorPalettes = [
    [new THREE.Color(0x4F46E5), new THREE.Color(0x7C3AED), new THREE.Color(0xC026D3), new THREE.Color(0xDB2777), new THREE.Color(0x8B5CF6)],
    [new THREE.Color(0xF59E0B), new THREE.Color(0xF97316), new THREE.Color(0xDC2626), new THREE.Color(0x7F1D1D), new THREE.Color(0xFBBF24)],
    [new THREE.Color(0xEC4899), new THREE.Color(0x8B5CF6), new THREE.Color(0x6366F1), new THREE.Color(0x3B82F6), new THREE.Color(0xA855F7)],
    [new THREE.Color(0x10B981), new THREE.Color(0xA3E635), new THREE.Color(0xFACC15), new THREE.Color(0xFB923C), new THREE.Color(0x4ADE80)]
  ];
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000000, 0.0015);
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1200);
  camera.position.set(0, 5, 22);
  const canvasElement = document.getElementById('neural-network-canvas'); // Get canvas element
  const renderer = new THREE.WebGLRenderer({
    canvas: canvasElement,
    antialias: true,
    powerPreference: "high-performance"
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000);
  renderer.outputColorSpace = THREE.SRGBColorSpace;

  function createStarfield() {
    const count = 5000,
      pos = [];
    for (let i = 0; i < count; i++) {
      const r = THREE.MathUtils.randFloat(40, 120);
      const phi = Math.acos(THREE.MathUtils.randFloatSpread(2));
      const theta = THREE.MathUtils.randFloat(0, Math.PI * 2);
      pos.push(
        r * Math.sin(phi) * Math.cos(theta),
        r * Math.sin(phi) * Math.sin(theta),
        r * Math.cos(phi)
      );
    }
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    const mat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.15,
      sizeAttenuation: true,
      depthWrite: false,
      opacity: 0.8,
      transparent: true
    });
    return new THREE.Points(geo, mat);
  }
  const starField = createStarfield();
  scene.add(starField);
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.rotateSpeed = 0.5;
  controls.minDistance = 5;
  controls.maxDistance = 100;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 0.15;
  controls.enablePan = false;
  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.68);
  composer.addPass(bloomPass);
  const filmPass = new FilmPass(0.35, 0.55, 2048, false);
  composer.addPass(filmPass);
  composer.addPass(new OutputPass());
  const pulseUniforms = {
    uTime: {
      value: 0.0
    },
    uPulsePositions: {
      value: [new THREE.Vector3(1e3, 1e3, 1e3), new THREE.Vector3(1e3, 1e3, 1e3), new THREE.Vector3(1e3, 1e3, 1e3)]
    },
    uPulseTimes: {
      value: [-1e3, -1e3, -1e3]
    },
    uPulseColors: {
      value: [new THREE.Color(1, 1, 1), new THREE.Color(1, 1, 1), new THREE.Color(1, 1, 1)]
    },
    uPulseSpeed: {
      value: 15.0
    },
    uBaseNodeSize: {
      value: 0.5
    },
    uActivePalette: {
      value: 0
    }
  };
  const noiseFunctions = `
        vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}
        vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}
        vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}
        vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}
        float snoise(vec3 v){
            const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);
            vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);
            vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);
            vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);
            vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));
            float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;
            vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);
            vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);
            vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;
            vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;
            vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);
            vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
            p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);
            m*=m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
        }
        float fbm(vec3 p,float time){
            float value=0.0;float amplitude=0.5;float frequency=1.0;int octaves=3;
            for(int i=0;i<octaves;i++){
                value+=amplitude*snoise(p*frequency+time*0.2*frequency);
                amplitude*=0.5;frequency*=2.0;
            }
            return value;
        }`;
  const nodeShader = {
    vertexShader: `${noiseFunctions}
            attribute float nodeSize;attribute float nodeType;attribute vec3 nodeColor;attribute vec3 connectionIndices;attribute float distanceFromRoot;
            uniform float uTime;uniform vec3 uPulsePositions[3];uniform float uPulseTimes[3];uniform float uPulseSpeed;uniform float uBaseNodeSize;
            varying vec3 vColor;varying float vNodeType;varying vec3 vPosition;varying float vPulseIntensity;varying float vDistanceFromRoot;

            float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime) {
                if (pulseTime < 0.0) return 0.0;
                float timeSinceClick = uTime - pulseTime;
                if (timeSinceClick < 0.0 || timeSinceClick > 3.0) return 0.0;

                float pulseRadius = timeSinceClick * uPulseSpeed;
                float distToClick = distance(worldPos, pulsePos);
                float pulseThickness = 2.0;
                float waveProximity = abs(distToClick - pulseRadius);

                return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(3.0, 0.0, timeSinceClick);
            }

            void main() {
                vNodeType = nodeType;
                vColor = nodeColor;
                vDistanceFromRoot = distanceFromRoot;

                vec3 worldPos = (modelMatrix * vec4(position, 1.0)).xyz;
                vPosition = worldPos;

                float totalPulseIntensity = 0.0;
                for (int i = 0; i < 3; i++) {
                    totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]);
                }
                vPulseIntensity = min(totalPulseIntensity, 1.0);

                float timeScale = 0.5 + 0.5 * sin(uTime * 0.8 + distanceFromRoot * 0.2);
                float baseSize = nodeSize * (0.8 + 0.2 * timeScale);
                float pulseSize = baseSize * (1.0 + vPulseIntensity * 2.0);

                vec3 modifiedPosition = position;
                if (nodeType > 0.5) {
                    float noise = fbm(position * 0.1, uTime * 0.1);
                    modifiedPosition += normal * noise * 0.2;
                }

                vec4 mvPosition = modelViewMatrix * vec4(modifiedPosition, 1.0);
                gl_PointSize = pulseSize * uBaseNodeSize * (800.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }`,
    fragmentShader: `
            uniform float uTime;uniform vec3 uPulseColors[3];uniform int uActivePalette;
            varying vec3 vColor;varying float vNodeType;varying vec3 vPosition;varying float vPulseIntensity;varying float vDistanceFromRoot;

            void main() {
                vec2 center = 2.0 * gl_PointCoord - 1.0;
                float dist = length(center);
                if (dist > 1.0) discard;

                float glowStrength = 1.0 - smoothstep(0.0, 1.0, dist);
                glowStrength = pow(glowStrength, 1.4);

                vec3 baseColor = vColor * (0.8 + 0.2 * sin(uTime * 0.5 + vDistanceFromRoot * 0.3));
                vec3 finalColor = baseColor;

                if (vPulseIntensity > 0.0) {
                    vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.3);
                    finalColor = mix(baseColor, pulseColor, vPulseIntensity);
                    finalColor *= (1.0 + vPulseIntensity * 0.7);
                }

                float alpha = glowStrength * (0.9 - 0.5 * dist);

                float camDistance = length(vPosition - cameraPosition);
                float distanceFade = smoothstep(80.0, 10.0, camDistance);

                if (vNodeType > 0.5) {
                    alpha *= 0.85;
                } else {
                    finalColor *= 1.2;
                }

                gl_FragColor = vec4(finalColor, alpha * distanceFade);
            }`
  };
  const connectionShader = {
    vertexShader: `${noiseFunctions}
            attribute vec3 startPoint;attribute vec3 endPoint;attribute float connectionStrength;attribute float pathIndex;attribute vec3 connectionColor;
            uniform float uTime;uniform vec3 uPulsePositions[3];uniform float uPulseTimes[3];uniform float uPulseSpeed;
            varying vec3 vColor;varying float vConnectionStrength;varying float vPulseIntensity;varying float vPathPosition;

            float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime) {
                if (pulseTime < 0.0) return 0.0;
                float timeSinceClick = uTime - pulseTime;
                if (timeSinceClick < 0.0 || timeSinceClick > 3.0) return 0.0;
                float pulseRadius = timeSinceClick * uPulseSpeed;
                float distToClick = distance(worldPos, pulsePos);
                float pulseThickness = 2.0;
                float waveProximity = abs(distToClick - pulseRadius);
                return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(3.0, 0.0, timeSinceClick);
            }

            void main() {
                float t = position.x;
                vPathPosition = t;

                vec3 midPoint = mix(startPoint, endPoint, 0.5);
                float pathOffset = sin(t * 3.14159) * 0.1;
                vec3 perpendicular = normalize(cross(normalize(endPoint - startPoint), vec3(0.0, 1.0, 0.0)));
                if (length(perpendicular) < 0.1) perpendicular = vec3(1.0, 0.0, 0.0);
                midPoint += perpendicular * pathOffset;

                vec3 p0 = mix(startPoint, midPoint, t);
                vec3 p1 = mix(midPoint, endPoint, t);
                vec3 finalPos = mix(p0, p1, t);

                float noiseTime = uTime * 0.2;
                float noise = fbm(vec3(pathIndex * 0.1, t * 0.5, noiseTime), noiseTime);
                finalPos += perpendicular * noise * 0.1;

                vec3 worldPos = (modelMatrix * vec4(finalPos, 1.0)).xyz;

                float totalPulseIntensity = 0.0;
                for (int i = 0; i < 3; i++) {
                    totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]);
                }
                vPulseIntensity = min(totalPulseIntensity, 1.0);

                vColor = connectionColor;
                vConnectionStrength = connectionStrength;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
            }`,
    fragmentShader: `
            uniform float uTime;uniform vec3 uPulseColors[3];
            varying vec3 vColor;varying float vConnectionStrength;varying float vPulseIntensity;varying float vPathPosition;

            void main() {
                vec3 baseColor = vColor * (0.7 + 0.3 * sin(uTime * 0.5 + vPathPosition * 10.0));

                float flowPattern = sin(vPathPosition * 20.0 - uTime * 3.0) * 0.5 + 0.5;
                float flowIntensity = 0.3 * flowPattern * vConnectionStrength;

                vec3 finalColor = baseColor;

                if (vPulseIntensity > 0.0) {
                    vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.3);
                    finalColor = mix(baseColor, pulseColor, vPulseIntensity);
                    flowIntensity += vPulseIntensity * 0.5;
                }

                finalColor *= (0.6 + flowIntensity + vConnectionStrength * 0.4);

                float alpha = 0.8 * vConnectionStrength + 0.2 * flowPattern;
                alpha = mix(alpha, min(1.0, alpha * 2.0), vPulseIntensity);

                gl_FragColor = vec4(finalColor, alpha);
            }`
  };
  class Node {
    constructor(position, level = 0, type = 0) {
      this.position = position;
      this.connections = [];
      this.level = level;
      this.type = type;
      this.size = type === 0 ? THREE.MathUtils.randFloat(0.7, 1.2) : THREE.MathUtils.randFloat(0.4, 0.9);
      this.distanceFromRoot = 0;
    }
    addConnection(node, strength = 1.0) {
      if (!this.isConnectedTo(node)) {
        this.connections.push({
          node,
          strength
        });
        node.connections.push({
          node: this,
          strength
        });
      }
    }
    isConnectedTo(node) {
      return this.connections.some(conn => conn.node === node);
    }
  }

  function generateNeuralNetwork(formationIndex, densityFactor = 1.0) {
    let nodes = [];
    let rootNode;

    function generateQuantumCortex() {
      rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);
      rootNode.size = 1.5;
      nodes.push(rootNode);
      const layers = 5,
        primaryAxes = 6,
        nodesPerAxis = 8,
        axisLength = 20;
      const axisEndpoints = [];
      for (let a = 0; a < primaryAxes; a++) {
        const phi = Math.acos(-1 + (2 * a) / primaryAxes);
        const theta = Math.PI * (1 + Math.sqrt(5)) * a;
        const dirVec = new THREE.Vector3(
          Math.sin(phi) * Math.cos(theta),
          Math.sin(phi) * Math.sin(theta),
          Math.cos(phi)
        );
        let prevNode = rootNode;
        for (let i = 1; i <= nodesPerAxis; i++) {
          const t = i / nodesPerAxis;
          const distance = axisLength * Math.pow(t, 0.8);
          const pos = new THREE.Vector3().copy(dirVec).multiplyScalar(distance);
          const nodeType = (i === nodesPerAxis) ? 1 : 0;
          const newNode = new Node(pos, i, nodeType);
          newNode.distanceFromRoot = distance;
          nodes.push(newNode);
          prevNode.addConnection(newNode, 1.0 - (t * 0.3));
          prevNode = newNode;
          if (i === nodesPerAxis) axisEndpoints.push(newNode);
        }
      }
      const ringDistances = [5, 10, 15];
      const ringNodes = [];
      for (const ringDist of ringDistances) {
        const nodesInRing = Math.floor(ringDist * 3 * densityFactor);
        const ringLayer = [];
        for (let i = 0; i < nodesInRing; i++) {
          const t = i / nodesInRing;
          const ringPhi = Math.acos(2 * Math.random() - 1);
          const ringTheta = 2 * Math.PI * t;
          const pos = new THREE.Vector3(
            ringDist * Math.sin(ringPhi) * Math.cos(ringTheta),
            ringDist * Math.sin(ringPhi) * Math.sin(ringTheta),
            ringDist * Math.cos(ringPhi)
          );
          const level = Math.ceil(ringDist / 5);
          const nodeType = Math.random() < 0.4 ? 1 : 0;
          const newNode = new Node(pos, level, nodeType);
          newNode.distanceFromRoot = ringDist;
          nodes.push(newNode);
          ringLayer.push(newNode);
        }
        ringNodes.push(ringLayer);
        for (let i = 0; i < ringLayer.length; i++) {
          const node = ringLayer[i];
          const nextNode = ringLayer[(i + 1) % ringLayer.length];
          node.addConnection(nextNode, 0.7);
          if (i % 4 === 0 && ringLayer.length > 5) {
            const jumpIdx = (i + Math.floor(ringLayer.length / 2)) % ringLayer.length;
            node.addConnection(ringLayer[jumpIdx], 0.4);
          }
        }
      }
      for (const ring of ringNodes) {
        for (const node of ring) {
          let closestAxisNode = null;
          let minDist = Infinity;
          for (const n of nodes) {
            if (n === rootNode || n === node) continue;
            if (n.level === 0 || n.type !== 0) continue;
            const dist = node.position.distanceTo(n.position);
            if (dist < minDist) {
              minDist = dist;
              closestAxisNode = n;
            }
          }
          if (closestAxisNode && minDist < 8) {
            const strength = 0.5 + (1 - minDist / 8) * 0.5;
            node.addConnection(closestAxisNode, strength);
          }
        }
      }
      for (let r = 0; r < ringNodes.length - 1; r++) {
        const innerRing = ringNodes[r];
        const outerRing = ringNodes[r + 1];
        const connectionsCount = Math.floor(innerRing.length * 0.5);
        for (let i = 0; i < connectionsCount; i++) {
          const innerNode = innerRing[Math.floor(Math.random() * innerRing.length)];
          const outerNode = outerRing[Math.floor(Math.random() * outerRing.length)];
          if (!innerNode.isConnectedTo(outerNode)) {
            innerNode.addConnection(outerNode, 0.6);
          }
        }
      }
      for (let i = 0; i < axisEndpoints.length; i++) {
        const startNode = axisEndpoints[i];
        const endNode = axisEndpoints[(i + 2) % axisEndpoints.length];
        const numIntermediates = 3;
        let prevNode = startNode;
        for (let j = 1; j <= numIntermediates; j++) {
          const t = j / (numIntermediates + 1);
          const pos = new THREE.Vector3().lerpVectors(startNode.position, endNode.position, t);
          pos.add(new THREE.Vector3(
            THREE.MathUtils.randFloatSpread(3),
            THREE.MathUtils.randFloatSpread(3),
            THREE.MathUtils.randFloatSpread(3)
          ));
          const newNode = new Node(pos, startNode.level, 0);
          newNode.distanceFromRoot = rootNode.position.distanceTo(pos);
          nodes.push(newNode);
          prevNode.addConnection(newNode, 0.5);
          prevNode = newNode;
        }
        prevNode.addConnection(endNode, 0.5);
      }
    }

    function generateHyperdimensionalMesh() {
      rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);
      rootNode.size = 1.5;
      nodes.push(rootNode);
      const dimensions = 4;
      const nodesPerDimension = Math.floor(40 * densityFactor);
      const maxRadius = 20;
      const dimensionVectors = [
        new THREE.Vector3(1, 1, 1).normalize(),
        new THREE.Vector3(-1, 1, -1).normalize(),
        new THREE.Vector3(1, -1, -1).normalize(),
        new THREE.Vector3(-1, -1, 1).normalize()
      ];
      const dimensionNodes = [];
      for (let d = 0; d < dimensions; d++) {
        const dimNodes = [];
        const dimVec = dimensionVectors[d];
        for (let i = 0; i < nodesPerDimension; i++) {
          const distance = maxRadius * Math.pow(Math.random(), 0.7);
          const randomVec = new THREE.Vector3(
            THREE.MathUtils.randFloatSpread(1),
            THREE.MathUtils.randFloatSpread(1),
            THREE.MathUtils.randFloatSpread(1)
          ).normalize();
          const biasedVec = new THREE.Vector3().addVectors(
            dimVec.clone().multiplyScalar(0.6 + Math.random() * 0.4),
            randomVec.clone().multiplyScalar(0.3)
          ).normalize();
          const pos = biasedVec.clone().multiplyScalar(distance);
          const isLeaf = Math.random() < 0.4 || distance > maxRadius * 0.8;
          const level = Math.floor(distance / (maxRadius / 4)) + 1;
          const newNode = new Node(pos, level, isLeaf ? 1 : 0);
          newNode.distanceFromRoot = distance;
          newNode.dimension = d;
          nodes.push(newNode);
          dimNodes.push(newNode);
          if (distance < maxRadius * 0.3) rootNode.addConnection(newNode, 0.7);
        }
        dimensionNodes.push(dimNodes);
      }
      for (let d = 0; d < dimensions; d++) {
        const dimNodes = dimensionNodes[d];
        dimNodes.sort((a, b) => a.distanceFromRoot - b.distanceFromRoot);
        const layers = 4;
        const nodesPerLayer = Math.ceil(dimNodes.length / layers);
        for (let layer = 0; layer < layers; layer++) {
          const startIdx = layer * nodesPerLayer;
          const endIdx = Math.min(startIdx + nodesPerLayer, dimNodes.length);
          for (let i = startIdx; i < endIdx; i++) {
            const node = dimNodes[i];
            const connectionsCount = 1 + Math.floor(Math.random() * 3);
            const nearbyNodes = dimNodes.slice(startIdx, endIdx).filter(n => n !== node)
              .sort((a, b) => node.position.distanceTo(a.position) - node.position.distanceTo(b.position));
            for (let j = 0; j < Math.min(connectionsCount, nearbyNodes.length); j++) {
              if (!node.isConnectedTo(nearbyNodes[j])) {
                node.addConnection(nearbyNodes[j], 0.4 + Math.random() * 0.4);
              }
            }
            if (layer > 0) {
              const prevLayer = dimNodes.slice((layer - 1) * nodesPerLayer, layer * nodesPerLayer)
                .sort((a, b) => node.position.distanceTo(a.position) - node.position.distanceTo(b.position));
              if (prevLayer.length > 0 && !node.isConnectedTo(prevLayer[0])) {
                node.addConnection(prevLayer[0], 0.8);
              }
            }
          }
        }
      }
      for (let d1 = 0; d1 < dimensions; d1++) {
        for (let d2 = d1 + 1; d2 < dimensions; d2++) {
          const connectionsCount = Math.floor(5 * densityFactor);
          for (let i = 0; i < connectionsCount; i++) {
            const n1 = dimensionNodes[d1][Math.floor(Math.random() * dimensionNodes[d1].length)];
            const n2 = dimensionNodes[d2][Math.floor(Math.random() * dimensionNodes[d2].length)];
            if (!n1.isConnectedTo(n2)) {
              const midPos = new THREE.Vector3().lerpVectors(n1.position, n2.position, 0.5);
              midPos.add(new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(2),
                THREE.MathUtils.randFloatSpread(2),
                THREE.MathUtils.randFloatSpread(2)
              ));
              const interNode = new Node(midPos, Math.max(n1.level, n2.level), 0);
              interNode.distanceFromRoot = rootNode.position.distanceTo(midPos);
              nodes.push(interNode);
              n1.addConnection(interNode, 0.5);
              interNode.addConnection(n2, 0.5);
            }
          }
        }
      }
      const jumpConnections = Math.floor(10 * densityFactor);
      for (let i = 0; i < jumpConnections; i++) {
        const startDim = Math.floor(Math.random() * dimensions);
        const endDim = (startDim + 2) % dimensions;
        const startNode = dimensionNodes[startDim][Math.floor(Math.random() * dimensionNodes[startDim].length)];
        const endNode = dimensionNodes[endDim][Math.floor(Math.random() * dimensionNodes[endDim].length)];
        if (!startNode.isConnectedTo(endNode)) {
          const numPoints = 3 + Math.floor(Math.random() * 3);
          let prevNode = startNode;
          for (let j = 1; j < numPoints; j++) {
            const t = j / numPoints;
            const pos = new THREE.Vector3().lerpVectors(startNode.position, endNode.position, t);
            pos.add(new THREE.Vector3(
              THREE.MathUtils.randFloatSpread(8) * Math.sin(t * Math.PI),
              THREE.MathUtils.randFloatSpread(8) * Math.sin(t * Math.PI),
              THREE.MathUtils.randFloatSpread(8) * Math.sin(t * Math.PI)
            ));
            const jumpNode = new Node(pos, Math.max(startNode.level, endNode.level), 0);
            jumpNode.distanceFromRoot = rootNode.position.distanceTo(pos);
            nodes.push(jumpNode);
            prevNode.addConnection(jumpNode, 0.4);
            prevNode = jumpNode;
          }
          prevNode.addConnection(endNode, 0.4);
        }
      }
    }

    function generateNeuralVortex() {
      rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);
      rootNode.size = 1.8;
      nodes.push(rootNode);
      const numSpirals = 6;
      const totalHeight = 30;
      const maxRadius = 16;
      const nodesPerSpiral = Math.floor(30 * densityFactor);
      const spiralNodes = [];
      for (let s = 0; s < numSpirals; s++) {
        const spiralPhase = (s / numSpirals) * Math.PI * 2;
        const spiralArray = [];
        for (let i = 0; i < nodesPerSpiral; i++) {
          const t = i / (nodesPerSpiral - 1);
          const heightCurve = 1 - Math.pow(2 * t - 1, 2);
          const height = (t - 0.5) * totalHeight;
          const radiusCurve = Math.sin(t * Math.PI);
          const radius = maxRadius * radiusCurve;
          const revolutions = 2.5;
          const angle = spiralPhase + t * Math.PI * 2 * revolutions;
          const pos = new THREE.Vector3(radius * Math.cos(angle), height, radius * Math.sin(angle));
          pos.add(new THREE.Vector3(
            THREE.MathUtils.randFloatSpread(1.5),
            THREE.MathUtils.randFloatSpread(1.5),
            THREE.MathUtils.randFloatSpread(1.5)
          ));
          const level = Math.floor(t * 5) + 1;
          const isLeaf = Math.random() < 0.3 || i > nodesPerSpiral - 3;
          const newNode = new Node(pos, level, isLeaf ? 1 : 0);
          newNode.distanceFromRoot = Math.sqrt(radius * radius + height * height);
          newNode.spiralIndex = s;
          newNode.spiralPosition = t;
          nodes.push(newNode);
          spiralArray.push(newNode);
        }
        spiralNodes.push(spiralArray);
      }
      for (const spiral of spiralNodes) {
        rootNode.addConnection(spiral[0], 1.0);
        for (let i = 0; i < spiral.length - 1; i++) {
          spiral[i].addConnection(spiral[i + 1], 0.9);
        }
      }
      for (let s = 0; s < numSpirals; s++) {
        const currentSpiral = spiralNodes[s];
        const nextSpiral = spiralNodes[(s + 1) % numSpirals];
        const connectionPoints = 5;
        for (let c = 0; c < connectionPoints; c++) {
          const t = c / (connectionPoints - 1);
          const idx1 = Math.floor(t * (currentSpiral.length - 1));
          const idx2 = Math.floor(t * (nextSpiral.length - 1));
          currentSpiral[idx1].addConnection(nextSpiral[idx2], 0.7);
        }
      }
      for (let s = 0; s < numSpirals; s++) {
        const currentSpiral = spiralNodes[s];
        const jumpSpiral = spiralNodes[(s + 2) % numSpirals];
        const connections = 3;
        for (let c = 0; c < connections; c++) {
          const t1 = (c + 0.5) / connections;
          const t2 = (c + 1.0) / connections;
          const idx1 = Math.floor(t1 * (currentSpiral.length - 1));
          const idx2 = Math.floor(t2 * (jumpSpiral.length - 1));
          const start = currentSpiral[idx1];
          const end = jumpSpiral[idx2];
          const midPoint = new THREE.Vector3().lerpVectors(start.position, end.position, 0.5).multiplyScalar(0.7);
          const bridgeNode = new Node(midPoint, Math.max(start.level, end.level), 0);
          bridgeNode.distanceFromRoot = rootNode.position.distanceTo(midPoint);
          nodes.push(bridgeNode);
          start.addConnection(bridgeNode, 0.6);
          bridgeNode.addConnection(end, 0.6);
        }
      }
      const ringLevels = 5;
      for (let r = 0; r < ringLevels; r++) {
        const height = (r / (ringLevels - 1) - 0.5) * totalHeight * 0.7;
        const ringNodes = nodes.filter(n => n !== rootNode && Math.abs(n.position.y - height) < 2);
        ringNodes.sort((a, b) => Math.atan2(a.position.z, a.position.x) - Math.atan2(b.position.z, b.position.x));
        if (ringNodes.length > 3) {
          for (let i = 0; i < ringNodes.length; i++) {
            ringNodes[i].addConnection(ringNodes[(i + 1) % ringNodes.length], 0.5);
          }
        }
      }
      const radialConnections = Math.floor(10 * densityFactor);
      const candidates = nodes.filter(n => n !== rootNode && n.position.length() > 5)
        .sort(() => Math.random() - 0.5)
        .slice(0, radialConnections);
      for (const node of candidates) {
        const numSegments = 1 + Math.floor(Math.random() * 2);
        let prevNode = node;
        for (let i = 1; i <= numSegments; i++) {
          const t = i / (numSegments + 1);
          const segPos = node.position.clone().multiplyScalar(1 - t);
          segPos.add(new THREE.Vector3(
            THREE.MathUtils.randFloatSpread(2),
            THREE.MathUtils.randFloatSpread(2),
            THREE.MathUtils.randFloatSpread(2)
          ));
          const newNode = new Node(segPos, Math.floor(node.level * (1 - t)), 0);
          newNode.distanceFromRoot = rootNode.position.distanceTo(segPos);
          nodes.push(newNode);
          prevNode.addConnection(newNode, 0.7);
          prevNode = newNode;
        }
        prevNode.addConnection(rootNode, 0.8);
      }
    }

    function generateSynapticCloud() {
      rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);
      rootNode.size = 1.5;
      nodes.push(rootNode);
      const numClusters = 6;
      const maxDist = 18;
      const clusterNodes = [];
      for (let c = 0; c < numClusters; c++) {
        const phi = Math.acos(2 * Math.random() - 1);
        const theta = 2 * Math.PI * Math.random();
        const distance = maxDist * (0.3 + 0.7 * Math.random());
        const pos = new THREE.Vector3(
          distance * Math.sin(phi) * Math.cos(theta),
          distance * Math.sin(phi) * Math.sin(theta),
          distance * Math.cos(phi)
        );
        const clusterNode = new Node(pos, 1, 0);
        clusterNode.size = 1.2;
        clusterNode.distanceFromRoot = distance;
        nodes.push(clusterNode);
        clusterNodes.push(clusterNode);
        rootNode.addConnection(clusterNode, 0.9);
      }
      for (let i = 0; i < clusterNodes.length; i++) {
        for (let j = i + 1; j < clusterNodes.length; j++) {
          const dist = clusterNodes[i].position.distanceTo(clusterNodes[j].position);
          const probability = 1.0 - (dist / (maxDist * 2));
          if (Math.random() < probability) {
            const strength = 0.5 + 0.5 * (1 - dist / (maxDist * 2));
            clusterNodes[i].addConnection(clusterNodes[j], strength);
          }
        }
      }
      for (const cluster of clusterNodes) {
        const clusterSize = Math.floor(20 * densityFactor);
        const cloudRadius = 7 + Math.random() * 3;
        for (let i = 0; i < clusterSize; i++) {
          const radius = cloudRadius * Math.pow(Math.random(), 0.5);
          const dir = new THREE.Vector3(
            THREE.MathUtils.randFloatSpread(2),
            THREE.MathUtils.randFloatSpread(2),
            THREE.MathUtils.randFloatSpread(2)
          ).normalize();
          const pos = new THREE.Vector3().copy(cluster.position).add(dir.multiplyScalar(radius));
          const distanceFromCluster = radius;
          const distanceFromRoot = rootNode.position.distanceTo(pos);
          const level = 2 + Math.floor(distanceFromCluster / 3);
          const isLeaf = Math.random() < 0.5;
          const newNode = new Node(pos, level, isLeaf ? 1 : 0);
          newNode.distanceFromRoot = distanceFromRoot;
          newNode.clusterRef = cluster;
          nodes.push(newNode);
          const strength = 0.7 * (1 - distanceFromCluster / cloudRadius);
          cluster.addConnection(newNode, strength);
          const nearbyNodes = nodes.filter(n =>
            n !== newNode && n !== cluster && n.clusterRef === cluster &&
            n.position.distanceTo(pos) < cloudRadius * 0.4
          );
          const connectionsCount = Math.floor(Math.random() * 3);
          nearbyNodes.sort((a, b) => pos.distanceTo(a.position) - pos.distanceTo(b.position));
          for (let j = 0; j < Math.min(connectionsCount, nearbyNodes.length); j++) {
            const dist = pos.distanceTo(nearbyNodes[j].position);
            const connStrength = 0.4 * (1 - dist / (cloudRadius * 0.4));
            newNode.addConnection(nearbyNodes[j], connStrength);
          }
        }
      }
      const interClusterCount = Math.floor(15 * densityFactor);
      for (let i = 0; i < interClusterCount; i++) {
        const cluster1 = clusterNodes[Math.floor(Math.random() * clusterNodes.length)];
        let cluster2;
        do {
          cluster2 = clusterNodes[Math.floor(Math.random() * clusterNodes.length)];
        } while (cluster2 === cluster1);
        const bridgePos = new THREE.Vector3().lerpVectors(cluster1.position, cluster2.position, 0.3 + Math.random() * 0.4);
        bridgePos.add(new THREE.Vector3(
          THREE.MathUtils.randFloatSpread(5),
          THREE.MathUtils.randFloatSpread(5),
          THREE.MathUtils.randFloatSpread(5)
        ));
        const bridgeNode = new Node(bridgePos, 2, 0);
        bridgeNode.distanceFromRoot = rootNode.position.distanceTo(bridgePos);
        nodes.push(bridgeNode);
        cluster1.addConnection(bridgeNode, 0.5);
        cluster2.addConnection(bridgeNode, 0.5);
        const nearbyNodes = nodes.filter(n => n !== bridgeNode && n !== cluster1 && n !== cluster2 && n.position.distanceTo(bridgePos) < 8);
        if (nearbyNodes.length > 0) {
          const target = nearbyNodes[Math.floor(Math.random() * nearbyNodes.length)];
          bridgeNode.addConnection(target, 0.4);
        }
      }
      const longRangeCount = Math.floor(10 * densityFactor);
      const outerNodes = nodes.filter(n => n.distanceFromRoot > maxDist * 0.6)
        .sort(() => Math.random() - 0.5)
        .slice(0, longRangeCount);
      for (const outerNode of outerNodes) {
        const numSegments = 2 + Math.floor(Math.random() * 2);
        let prevNode = outerNode;
        for (let i = 1; i <= numSegments; i++) {
          const t = i / (numSegments + 1);
          const segPos = outerNode.position.clone().multiplyScalar(1 - t * 0.8);
          segPos.add(new THREE.Vector3(
            THREE.MathUtils.randFloatSpread(4),
            THREE.MathUtils.randFloatSpread(4),
            THREE.MathUtils.randFloatSpread(4)
          ));
          const newNode = new Node(segPos, outerNode.level, 0);
          newNode.distanceFromRoot = rootNode.position.distanceTo(segPos);
          nodes.push(newNode);
          prevNode.addConnection(newNode, 0.6);
          prevNode = newNode;
        }
        const innerNodes = nodes.filter(n => n.distanceFromRoot < maxDist * 0.4 && n !== rootNode);
        if (innerNodes.length > 0) {
          const targetNode = innerNodes[Math.floor(Math.random() * innerNodes.length)];
          prevNode.addConnection(targetNode, 0.5);
        }
      }
    }
    switch (formationIndex % 4) {
      case 0:
        generateQuantumCortex();
        break;
      case 1:
        generateHyperdimensionalMesh();
        break;
      case 2:
        generateNeuralVortex();
        break;
      case 3:
        generateSynapticCloud();
        break;
    }
    if (densityFactor < 1.0) {
      const originalNodeCount = nodes.length;
      nodes = nodes.filter((node, index) => {
        if (node === rootNode) return true;
        const hash = (index * 31 + Math.floor(densityFactor * 100)) % 100;
        return hash < (densityFactor * 100);
      });
      nodes.forEach(node => {
        node.connections = node.connections.filter(conn => nodes.includes(conn.node));
      });
      console.log(`Density Filter: ${originalNodeCount} -> ${nodes.length} nodes`);
    }
    return {
      nodes,
      rootNode
    };
  }
  let neuralNetwork = null,
    nodesMesh = null,
    connectionsMesh = null;

  function createNetworkVisualization(formationIndex, densityFactor = 1.0) {
    console.log(`Creating formation ${formationIndex}, density ${densityFactor}`);
    if (nodesMesh) {
      scene.remove(nodesMesh);
      nodesMesh.geometry.dispose();
      nodesMesh.material.dispose();
      nodesMesh = null;
    }
    if (connectionsMesh) {
      scene.remove(connectionsMesh);
      connectionsMesh.geometry.dispose();
      connectionsMesh.material.dispose();
      connectionsMesh = null;
    }
    neuralNetwork = generateNeuralNetwork(formationIndex, densityFactor);
    if (!neuralNetwork || neuralNetwork.nodes.length === 0) {
      console.error("Network generation failed or resulted in zero nodes.");
      return;
    }
    const nodesGeometry = new THREE.BufferGeometry();
    const nodePositions = [],
      nodeTypes = [],
      nodeSizes = [],
      nodeColors = [],
      connectionIndices = [],
      distancesFromRoot = [];
    neuralNetwork.nodes.forEach((node, index) => {
      nodePositions.push(node.position.x, node.position.y, node.position.z);
      nodeTypes.push(node.type);
      nodeSizes.push(node.size);
      distancesFromRoot.push(node.distanceFromRoot);
      const indices = node.connections.slice(0, 3).map(conn => neuralNetwork.nodes.indexOf(conn.node));
      while (indices.length < 3) indices.push(-1);
      connectionIndices.push(...indices);
      const palette = colorPalettes[config.activePaletteIndex];
      const colorIndex = Math.min(node.level, palette.length - 1);
      const baseColor = palette[colorIndex % palette.length].clone();
      baseColor.offsetHSL(
        THREE.MathUtils.randFloatSpread(0.05),
        THREE.MathUtils.randFloatSpread(0.1),
        THREE.MathUtils.randFloatSpread(0.1)
      );
      nodeColors.push(baseColor.r, baseColor.g, baseColor.b);
    });
    nodesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(nodePositions, 3));
    nodesGeometry.setAttribute('nodeType', new THREE.Float32BufferAttribute(nodeTypes, 1));
    nodesGeometry.setAttribute('nodeSize', new THREE.Float32BufferAttribute(nodeSizes, 1));
    nodesGeometry.setAttribute('nodeColor', new THREE.Float32BufferAttribute(nodeColors, 3));
    nodesGeometry.setAttribute('connectionIndices', new THREE.Float32BufferAttribute(connectionIndices, 3));
    nodesGeometry.setAttribute('distanceFromRoot', new THREE.Float32BufferAttribute(distancesFromRoot, 1));
    const nodesMaterial = new THREE.ShaderMaterial({
      uniforms: THREE.UniformsUtils.clone(pulseUniforms),
      vertexShader: nodeShader.vertexShader,
      fragmentShader: nodeShader.fragmentShader,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    nodesMesh = new THREE.Points(nodesGeometry, nodesMaterial);
    scene.add(nodesMesh);
    const connectionsGeometry = new THREE.BufferGeometry();
    const connectionColors = [],
      connectionStrengths = [],
      connectionPositions = [],
      startPoints = [],
      endPoints = [],
      pathIndices = [];
    const processedConnections = new Set();
    let pathIndex = 0;
    neuralNetwork.nodes.forEach((node, nodeIndex) => {
      node.connections.forEach(connection => {
        const connectedNode = connection.node;
        const connectedIndex = neuralNetwork.nodes.indexOf(connectedNode);
        if (connectedIndex === -1) return;
        const key = [Math.min(nodeIndex, connectedIndex), Math.max(nodeIndex, connectedIndex)].join('-');
        if (!processedConnections.has(key)) {
          processedConnections.add(key);
          const startPoint = node.position;
          const endPoint = connectedNode.position;
          const numSegments = 15;
          for (let i = 0; i < numSegments; i++) {
            const t = i / (numSegments - 1);
            connectionPositions.push(t, 0, 0);
            startPoints.push(startPoint.x, startPoint.y, startPoint.z);
            endPoints.push(endPoint.x, endPoint.y, endPoint.z);
            pathIndices.push(pathIndex);
            connectionStrengths.push(connection.strength);
            const palette = colorPalettes[config.activePaletteIndex];
            const avgLevel = Math.min(Math.floor((node.level + connectedNode.level) / 2), palette.length - 1);
            const baseColor = palette[avgLevel % palette.length].clone();
            baseColor.offsetHSL(
              THREE.MathUtils.randFloatSpread(0.05),
              THREE.MathUtils.randFloatSpread(0.1),
              THREE.MathUtils.randFloatSpread(0.1)
            );
            connectionColors.push(baseColor.r, baseColor.g, baseColor.b);
          }
          pathIndex++;
        }
      });
    });
    connectionsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(connectionPositions, 3));
    connectionsGeometry.setAttribute('startPoint', new THREE.Float32BufferAttribute(startPoints, 3));
    connectionsGeometry.setAttribute('endPoint', new THREE.Float32BufferAttribute(endPoints, 3));
    connectionsGeometry.setAttribute('connectionStrength', new THREE.Float32BufferAttribute(connectionStrengths, 1));
    connectionsGeometry.setAttribute('connectionColor', new THREE.Float32BufferAttribute(connectionColors, 3));
    connectionsGeometry.setAttribute('pathIndex', new THREE.Float32BufferAttribute(pathIndices, 1));
    const connectionsMaterial = new THREE.ShaderMaterial({
      uniforms: THREE.UniformsUtils.clone(pulseUniforms),
      vertexShader: connectionShader.vertexShader,
      fragmentShader: connectionShader.fragmentShader,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    connectionsMesh = new THREE.LineSegments(connectionsGeometry, connectionsMaterial);
    scene.add(connectionsMesh);
    const palette = colorPalettes[config.activePaletteIndex];
    connectionsMaterial.uniforms.uPulseColors.value[0].copy(palette[0]);
    connectionsMaterial.uniforms.uPulseColors.value[1].copy(palette[1]);
    connectionsMaterial.uniforms.uPulseColors.value[2].copy(palette[2]);
    nodesMaterial.uniforms.uPulseColors.value[0].copy(palette[0]);
    nodesMaterial.uniforms.uPulseColors.value[1].copy(palette[1]);
    nodesMaterial.uniforms.uPulseColors.value[2].copy(palette[2]);
    nodesMaterial.uniforms.uActivePalette.value = config.activePaletteIndex;
  }

  function updateTheme(paletteIndex) {
    config.activePaletteIndex = paletteIndex;
    if (!nodesMesh || !connectionsMesh) return;
    const palette = colorPalettes[paletteIndex];
    const nodeColorsAttr = nodesMesh.geometry.attributes.nodeColor;
    const nodeLevels = neuralNetwork.nodes.map(n => n.level);
    for (let i = 0; i < nodeColorsAttr.count; i++) {
      const node = neuralNetwork.nodes[i];
      if (!node) continue;
      const colorIndex = Math.min(node.level, palette.length - 1);
      const baseColor = palette[colorIndex % palette.length].clone();
      baseColor.offsetHSL(
        THREE.MathUtils.randFloatSpread(0.05),
        THREE.MathUtils.randFloatSpread(0.1),
        THREE.MathUtils.randFloatSpread(0.1)
      );
      nodeColorsAttr.setXYZ(i, baseColor.r, baseColor.g, baseColor.b);
    }
    nodeColorsAttr.needsUpdate = true;
    const connectionColors = [];
    const processedConnections = new Set();
    neuralNetwork.nodes.forEach((node, nodeIndex) => {
      node.connections.forEach(connection => {
        const connectedNode = connection.node;
        const connectedIndex = neuralNetwork.nodes.indexOf(connectedNode);
        if (connectedIndex === -1) return;
        const key = [Math.min(nodeIndex, connectedIndex), Math.max(nodeIndex, connectedIndex)].join('-');
        if (!processedConnections.has(key)) {
          processedConnections.add(key);
          const numSegments = 15;
          for (let i = 0; i < numSegments; i++) {
            const avgLevel = Math.min(Math.floor((node.level + connectedNode.level) / 2), palette.length - 1);
            const baseColor = palette[avgLevel % palette.length].clone();
            baseColor.offsetHSL(
              THREE.MathUtils.randFloatSpread(0.05),
              THREE.MathUtils.randFloatSpread(0.1),
              THREE.MathUtils.randFloatSpread(0.1)
            );
            connectionColors.push(baseColor.r, baseColor.g, baseColor.b);
          }
        }
      });
    });
    connectionsMesh.geometry.setAttribute('connectionColor', new THREE.Float32BufferAttribute(connectionColors, 3));
    connectionsMesh.geometry.attributes.connectionColor.needsUpdate = true;
    nodesMesh.material.uniforms.uPulseColors.value.forEach((c, i) => c.copy(palette[i % palette.length]));
    connectionsMesh.material.uniforms.uPulseColors.value.forEach((c, i) => c.copy(palette[i % palette.length]));
    nodesMesh.material.uniforms.uActivePalette.value = paletteIndex;
  }
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();
  const interactionPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
  const interactionPoint = new THREE.Vector3();
  let lastPulseIndex = 0;

  function triggerPulse(clientX, clientY) {
    pointer.x = (clientX / window.innerWidth) * 2 - 1;
    pointer.y = -(clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(pointer, camera);
    interactionPlane.normal.copy(camera.position).normalize();
    interactionPlane.constant = -interactionPlane.normal.dot(camera.position) + camera.position.length() * 0.5;
    if (raycaster.ray.intersectPlane(interactionPlane, interactionPoint)) {
      const time = clock.getElapsedTime();
      if (nodesMesh && connectionsMesh) {
        lastPulseIndex = (lastPulseIndex + 1) % 3;
        nodesMesh.material.uniforms.uPulsePositions.value[lastPulseIndex].copy(interactionPoint);
        nodesMesh.material.uniforms.uPulseTimes.value[lastPulseIndex] = time;
        connectionsMesh.material.uniforms.uPulsePositions.value[lastPulseIndex].copy(interactionPoint);
        connectionsMesh.material.uniforms.uPulseTimes.value[lastPulseIndex] = time;
        const palette = colorPalettes[config.activePaletteIndex];
        const randomColor = palette[Math.floor(Math.random() * palette.length)];
        nodesMesh.material.uniforms.uPulseColors.value[lastPulseIndex].copy(randomColor);
        connectionsMesh.material.uniforms.uPulseColors.value[lastPulseIndex].copy(randomColor);
      }
    }
  }
  renderer.domElement.addEventListener('click', (e) => {
    if (e.target.closest('.ui-panel, #control-buttons')) return;
    if (!config.paused) triggerPulse(e.clientX, e.clientY);
  });
  renderer.domElement.addEventListener('touchstart', (e) => {
    if (e.target.closest('.ui-panel, #control-buttons')) return;
    e.preventDefault();
    if (e.touches.length > 0 && !config.paused) {
      triggerPulse(e.touches[0].clientX, e.touches[0].clientY);
    }
  }, {
    passive: false
  });
  const themeButtons = document.querySelectorAll('.theme-button');
  themeButtons.forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const idx = parseInt(btn.dataset.theme, 10);
      updateTheme(idx);
      themeButtons.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
    });
  });
  const densitySlider = document.getElementById('density-slider');
  const densityValue = document.getElementById('density-value');
  let densityTimeout;
  densitySlider.addEventListener('input', (e) => {
    e.stopPropagation();
    const val = parseInt(densitySlider.value, 10);
    config.densityFactor = val / 100;
    densityValue.textContent = `${val}%`;
    clearTimeout(densityTimeout);
    densityTimeout = setTimeout(() => {
      createNetworkVisualization(config.currentFormation, config.densityFactor);
    }, 300);
  });
  const changeFormationBtn = document.getElementById('change-formation-btn');
  const pausePlayBtn = document.getElementById('pause-play-btn');
  const resetCameraBtn = document.getElementById('reset-camera-btn');
  changeFormationBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    config.currentFormation = (config.currentFormation + 1) % config.numFormations;
    createNetworkVisualization(config.currentFormation, config.densityFactor);
    controls.autoRotate = false;
    setTimeout(() => {
      controls.autoRotate = true;
    }, 2000);
  });
  pausePlayBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    config.paused = !config.paused;
    pausePlayBtn.textContent = config.paused ? 'Play' : 'Pause';
    controls.autoRotate = !config.paused;
  });
  resetCameraBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    controls.reset();
    controls.autoRotate = false;
    setTimeout(() => {
      controls.autoRotate = true;
    }, 1500);
  });
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();
    if (!config.paused) {
      if (nodesMesh) {
        nodesMesh.material.uniforms.uTime.value = t;
        nodesMesh.rotation.y = Math.sin(t * 0.05) * 0.08;
      }
      if (connectionsMesh) {
        connectionsMesh.material.uniforms.uTime.value = t;
        connectionsMesh.rotation.y = Math.sin(t * 0.05) * 0.08;
      }
    }
    starField.rotation.y += 0.0003;
    controls.update();
    composer.render();
  }

  function init() {
    createNetworkVisualization(config.currentFormation, config.densityFactor);
    document.querySelectorAll('.theme-button').forEach(b => b.classList.remove('active'));
    document.querySelector(`.theme-button[data-theme="${config.activePaletteIndex}"]`).classList.add('active');
    updateTheme(config.activePaletteIndex);
    animate();
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
    bloomPass.resolution.set(window.innerWidth, window.innerHeight);
  }
  window.addEventListener('resize', onWindowResize);
  init();
</script>
